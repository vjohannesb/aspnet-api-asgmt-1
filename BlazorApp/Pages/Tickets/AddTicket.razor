@page "/addticket"
@* "Egen" URI (istället för /tickets/add) då "Add Ticket" är ett eget menyval, 
och NavLink matchar URI:n till /tickets vilket gör att både Add Ticket och Tickets blir .active när man är på Add Ticket.
Kan ej använda NavLinkMatch.All då det tar bort .active när man ex. är inne på en specifik ticket*@
@inject ILogger<AddTicket> _logger
<ValidateToken />

<h3>Register new ticket</h3>
<TimeDisplay />
<MessageBox Message="@_message" Error="@_error" LinkAction="GoToTicket" MethodMessage="Go to ticket" />

@if (_administrators == null)
{
    <p>Loading...</p>
}
else
{
    <EditForm Model="ticket" OnValidSubmit="SubmitTicket">
        <DataAnnotationsValidator />

        <div class="mb-3">
            <label class="form-label">Description</label>
            <InputTextArea @bind-Value="@ticket.Description" class="form-control" rows="3" />
            <ValidationMessage For="() => ticket.Description" />
        </div>

        <div class="mb-3">
            <label class="form-label">Status</label>
            <InputSelect @bind-Value="@ticket.Status" class="form-select" aria-label="Select ticket status">
                <option value="@TicketStatus.Open">Open</option>
                <option value="@TicketStatus.Active">Active</option>
                <option value="@TicketStatus.Closed">Closed</option>
            </InputSelect>
        </div>

        <div class="mb-3">
            <label class="form-label">Customer</label>
            <InputSelect @bind-Value="@ticket.CustomerId" class="form-select" aria-label="Select a customer">
                <option value="">Select a customer...</option>
                @if (_customers != null)
                    {
                    @foreach (var customer in _customers)
                        {
                        <option value="@customer.CustomerId">
                            @customer.DisplayName
                        </option>
                        }
                    }
            </InputSelect>
        </div>

        <div class="mb-3">
            <label class="form-label">Assign an administrator</label>
            <InputSelect @bind-Value="@ticket.AssignedAdminId" class="form-select" aria-label="Select an administrator">
                <option value="">Select an administrator...</option>
                @if (_administrators != null)
                    {
                    @foreach (var admin in _administrators)
                        {
                        <option value="@admin.AdminId">
                            @admin.DisplayName
                        </option>
                        }
                    }
            </InputSelect>
        </div>

        <button type="submit" class="btn btn-success" disabled=@submitting>Submit</button>
        <button class="btn btn-secondary ms-2" @onclick="GoToList" disabled=@submitting>Back to List</button>
    </EditForm>

}


@code {
    private TicketModel ticket;
    private IEnumerable<AdminViewModel> _administrators;
    private IEnumerable<CustomerModel> _customers;

    private bool submitting = false;
    private string now;
    private string _token;
    private string _location;
    private string _error;
    private string _message;

    private string _adminUrl = "https://localhost:44330/api/admin";
    private string _customersUrl = "https://localhost:44330/api/customers";
    private string _ticketsUrl = "https://localhost:44330/api/tickets";

    protected override async Task OnInitializedAsync()
    {
        ticket = new TicketModel();
        now = DateTime.Now.ToString("yyyy-MM-dd HH:mm");

        var adminResponse = await apiService.SendToAPIAsync(HttpMethod.Get, _adminUrl, auth: true);
        if (adminResponse.IsSuccessStatusCode)
        {
            _administrators = await adminResponse.Content.ReadFromJsonAsync<AdminViewModel[]>();
            var customerResponse = await apiService.SendToAPIAsync(HttpMethod.Get, _customersUrl, auth: true);
            if (customerResponse.IsSuccessStatusCode)
                _customers = await customerResponse.Content.ReadFromJsonAsync<CustomerModel[]>();
        }
        else
        {
            _error = $"Could not connect to API. {(int)adminResponse.StatusCode} {adminResponse.ReasonPhrase}";
            _message = string.Empty;
            apiService.LogWarningIfDebug(await adminResponse.Content.ReadAsStringAsync(), _logger);
        }
    }

    private async Task SubmitTicket()
    {
        _location = string.Empty;
        _error = string.Empty;
        _message = string.Empty;
        submitting = true;

        var response = await apiService.SendToAPIAsync(HttpMethod.Post, _ticketsUrl, ticket, true);
        if (response.IsSuccessStatusCode)
        {
            ticket = new TicketModel();

            // POST Ticket returnerar ticket-id i Result-fältet
            var payload = await response.Content.ReadFromJsonAsync<ResponseModel>();
            _location = $"/tickets/{payload.Result}";
            _message = "Ticket created! ";
        }
        else
        {
            _error = $"Could not create ticket. {(int)response.StatusCode} {response.ReasonPhrase}";
            apiService.LogWarningIfDebug(await response.Content.ReadAsStringAsync(), _logger);
        }

        submitting = false;
    }

    private void GoToTicket()
        => navigationManager.NavigateTo(_location);

    private void GoToList()
        => navigationManager.NavigateTo("/tickets");
}
